<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Native Audio Chat</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }

        .chat-container {
            width: 100%;
            max-width: 400px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .logo {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .mic-button {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 48px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.3);
        }

        .mic-button.recording {
            background: linear-gradient(45deg, #ff4757, #c44569);
            animation: pulse 1.5s ease-in-out infinite alternate;
        }

        .mic-button.connected {
            background: linear-gradient(45deg, #2ed573, #1e90ff);
        }

        .mic-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .status {
            font-size: 16px;
            margin-bottom: 20px;
            min-height: 24px;
            font-weight: 500;
        }

        .status.connected {
            color: #2ed573;
        }

        .status.error {
            color: #ff6b6b;
        }

        .status.recording {
            color: #ffa726;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .waveform {
            width: 100%;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .wave-bar {
            width: 3px;
            background: rgba(255, 255, 255, 0.6);
            margin: 0 1px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .conversation-log {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: left;
            font-size: 14px;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 12px;
            word-wrap: break-word;
        }

        .message.user {
            background: rgba(33, 150, 243, 0.3);
            margin-left: 20px;
        }

        .message.ai {
            background: rgba(76, 175, 80, 0.3);
            margin-right: 20px;
        }

        .session-info {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .debug-info {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            text-align: left;
            max-height: 100px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="logo">üéôÔ∏è</div>
        <h1 class="title">Gemini Native Audio</h1>
        <p class="subtitle">Real-time AI voice conversation</p>
        
        <div class="status" id="status">Initializing...</div>
        
        <button class="mic-button" id="micButton" disabled>
            üé§
        </button>
        
        <div class="waveform" id="waveform">
            <!-- Wave bars will be generated here -->
        </div>
        
        <div class="controls">
            <button class="control-btn" id="connectBtn" disabled>Connect</button>
            <button class="control-btn" id="disconnectBtn" disabled>Disconnect</button>
        </div>
        
        <div class="conversation-log" id="conversationLog">
            <div class="message ai">üëã Hi! Click Connect to start our native audio conversation with affective dialog!</div>
        </div>
        
        <div class="session-info" id="sessionInfo">
            Session: Loading...
        </div>
        
        <div class="debug-info" id="debugInfo">
            Debug info will appear here...
        </div>
    </div>

    <script type="module">
        class GeminiNativeAudioChat {
            constructor() {
                this.sessionToken = null;
                this.geminiClient = null;
                this.liveSession = null;
                this.isRecording = false;
                this.isConnected = false;
                this.mediaRecorder = null;
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationId = null;
                this.responseQueue = [];
                this.audioChunks = [];
                
                this.initializeUI();
                this.initializeSession();
            }

            initializeUI() {
                this.statusEl = document.getElementById('status');
                this.micButton = document.getElementById('micButton');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.conversationLog = document.getElementById('conversationLog');
                this.sessionInfo = document.getElementById('sessionInfo');
                this.waveform = document.getElementById('waveform');
                this.debugInfo = document.getElementById('debugInfo');

                // Event listeners
                this.micButton.addEventListener('click', () => this.toggleRecording());
                this.connectBtn.addEventListener('click', () => this.connectToWebSocket());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());

                // Generate wave bars
                this.generateWaveBars();
            }

            generateWaveBars() {
                this.waveform.innerHTML = '';
                for (let i = 0; i < 50; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    bar.style.height = '10px';
                    this.waveform.appendChild(bar);
                }
            }

            addDebugInfo(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.debugInfo.innerHTML += `${timestamp}: ${message}<br>`;
                this.debugInfo.scrollTop = this.debugInfo.scrollHeight;
                console.log(message);
            }

            async initializeSession() {
                try {
                    this.addDebugInfo('Starting session initialization...');
                    
                    // Get session token from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    this.sessionToken = urlParams.get('session');
                    
                    if (!this.sessionToken) {
                        throw new Error('No session token provided');
                    }

                    this.addDebugInfo(`Session token: ${this.sessionToken.substring(0, 20)}...`);
                    this.updateStatus('Getting session config...');
                    
                    // Get session configuration from n8n
                    const apiUrl = `https://n8n.lomeai.com/webhook/voice-session?session=${this.sessionToken}&action=initialize`;
                    this.addDebugInfo(`Calling API: ${apiUrl}`);
                    
                    const response = await fetch(apiUrl);
                    const rawData = await response.json();
                    
                    this.addDebugInfo(`Raw response: ${JSON.stringify(rawData).substring(0, 200)}...`);
                    
                    // Handle the response format from n8n
                    let data;
                    if (Array.isArray(rawData) && rawData.length > 0) {
                        data = rawData[0];
                        this.addDebugInfo('Parsed array response');
                    } else {
                        data = rawData;
                        this.addDebugInfo('Direct response format');
                    }
                    
                    if (!data || !data.success) {
                        throw new Error(data?.error || 'Failed to initialize session');
                    }

                    this.sessionConfig = data.config;
                    this.sessionInfo.textContent = `Session: ${data.sessionId} | User: ${data.userId}`;
                    
                    this.addDebugInfo(`Model: ${this.sessionConfig.model}`);
                    this.addDebugInfo(`API Key: ${this.sessionConfig.apiKey ? 'Present' : 'Missing'}`);
                    
                    this.updateStatus('Ready to connect');
                    this.connectBtn.disabled = false;
                    
                } catch (error) {
                    this.addDebugInfo(`Session init error: ${error.message}`);
                    console.error('Session initialization failed:', error);
                    this.updateStatus('Failed to initialize session: ' + error.message, 'error');
                }
            }

            async connectToWebSocket() {
                try {
                    this.addDebugInfo('Connecting to WebSocket proxy...');
                    
                    // Get the WebSocket URL from the session config
                    const wsUrl = this.sessionConfig.websocketProxyUrl;
                    if (!wsUrl) {
                        throw new Error('No WebSocket proxy URL provided');
                    }
                    
                    // Create WebSocket connection with session token
                    this.ws = new WebSocket(`${wsUrl}&session=${this.sessionToken}`);
                    
                    // Set up WebSocket handlers
                    this.ws.onopen = () => {
                        this.addDebugInfo('WebSocket connection opened');
                        this.isConnected = true;
                        this.updateStatus('Connected! Click microphone to talk', 'connected');
                        this.micButton.disabled = false;
                        this.micButton.classList.add('connected');
                        this.disconnectBtn.disabled = false;
                        this.connectBtn.disabled = true;
                        this.addMessage('ü§ñ Connected! I can hear you now. Click the microphone to start talking!', 'ai');
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            this.handleWebSocketMessage(message);
                        } catch (error) {
                            this.addDebugInfo(`Failed to parse message: ${error.message}`);
                        }
                    };
                    
                    this.ws.onerror = (error) => {
                        this.addDebugInfo(`WebSocket error: ${error.message}`);
                        this.updateStatus('Connection error', 'error');
                        this.handleDisconnection();
                    };
                    
                    this.ws.onclose = (event) => {
                        this.addDebugInfo(`WebSocket closed: ${event.reason}`);
                        this.updateStatus('Connection closed', 'error');
                        this.handleDisconnection();
                    };
                    
                } catch (error) {
                    this.addDebugInfo(`Connection error: ${error.message}`);
                    console.error('Failed to connect:', error);
                    this.updateStatus('Connection failed: ' + error.message, 'error');
                    this.connectBtn.disabled = false;
                }
            }

            handleWebSocketMessage(message) {
                switch (message.type) {
                    case 'audio_response':
                        this.playAudioResponse(message.audioData);
                        break;
                        
                    case 'text_response':
                        this.addMessage('ü§ñ ' + message.text, 'ai');
                        break;
                        
                    case 'error':
                        this.addDebugInfo(`Server error: ${message.message}`);
                        this.updateStatus(message.message, 'error');
                        break;
                        
                    case 'turn_complete':
                        this.addDebugInfo('Turn completed');
                        break;
                        
                    default:
                        this.addDebugInfo(`Unknown message type: ${message.type}`);
                }
            }

            async sendAudioToServer(audioData) {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.addDebugInfo('WebSocket not connected');
                    return;
                }

                try {
                    this.ws.send(JSON.stringify({
                        type: 'audio_input',
                        audioData: audioData,
                        mimeType: 'audio/pcm;rate=16000'
                    }));
                    
                    this.addDebugInfo(`Audio sent: ${audioData.length} bytes`);
                    
                } catch (error) {
                    this.addDebugInfo(`Failed to send audio: ${error.message}`);
                    console.error('Error sending audio:', error);
                }
            }

            async handleGeminiMessage(message) {
                // Handle different message types from Gemini Live API
                if (message.text) {
                    this.addMessage('ü§ñ ' + message.text, 'ai');
                    this.addDebugInfo(`Text response: ${message.text.substring(0, 50)}...`);
                }
                
                if (message.data) {
                    // Handle native audio response (24kHz PCM as per docs)
                    this.addDebugInfo(`Audio response received: ${message.data.length} bytes`);
                    await this.playAudioResponse(message.data);
                }
                
                if (message.serverContent) {
                    this.addDebugInfo('Server content received');
                    if (message.serverContent.turnComplete) {
                        this.addDebugInfo('Turn completed');
                    }
                }
            }

            async playAudioResponse(audioData) {
                try {
                    this.addDebugInfo('Playing audio response...');
                    
                    // Convert base64 audio to playable format
                    // According to docs: Audio output always uses 24kHz, 16-bit PCM
                    const binaryString = window.atob(audioData);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    
                    // Create audio context and decode
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // For 24kHz PCM audio from Gemini
                    const sampleRate = 24000;
                    const channels = 1;
                    const audioBuffer = audioContext.createBuffer(channels, bytes.length / 2, sampleRate);
                    
                    // Convert bytes to 16-bit PCM samples
                    const channelData = audioBuffer.getChannelData(0);
                    for (let i = 0; i < channelData.length; i++) {
                        const sample = (bytes[i * 2 + 1] << 8) | bytes[i * 2];
                        channelData[i] = sample < 32768 ? sample / 32768 : (sample - 65536) / 32768;
                    }
                    
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);
                    source.start();
                    
                    this.addMessage('üîä [Playing native audio response]', 'ai');
                    this.addDebugInfo('Audio playback started');
                    
                } catch (error) {
                    this.addDebugInfo(`Audio playback error: ${error.message}`);
                    console.error('Error playing audio:', error);
                    this.addMessage('üîä [Received audio response - playback failed]', 'ai');
                }
            }

            async toggleRecording() {
                if (!this.isConnected) {
                    this.updateStatus('Please connect first', 'error');
                    return;
                }

                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    await this.startRecording();
                }
            }

            async startRecording() {
                try {
                    this.addDebugInfo('Starting audio recording...');
                    
                    // Request microphone access with correct format for Gemini
                    // Input audio is natively 16kHz but API will resample as needed
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        } 
                    });

                    this.addDebugInfo('Microphone access granted');

                    // Set up audio context for visualization
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);

                    this.analyser.fftSize = 256;
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);

                    // Start continuous recording for real-time streaming
                    this.stream = stream;
                    this.isRecording = true;
                    
                    this.micButton.classList.add('recording');
                    this.micButton.innerHTML = '‚èπÔ∏è';
                    this.updateStatus('Recording... Click to stop', 'recording');
                    
                    this.startWaveAnimation();
                    this.addMessage('üé§ Recording started - streaming to Gemini...', 'user');
                    
                    // Start streaming audio to Gemini in real-time
                    this.startAudioStreaming();

                } catch (error) {
                    this.addDebugInfo(`Recording start error: ${error.message}`);
                    console.error('Failed to start recording:', error);
                    this.updateStatus('Microphone access denied: ' + error.message, 'error');
                }
            }

            async startAudioStreaming() {
                try {
                    // Create a media recorder for real-time streaming
                    this.mediaRecorder = new MediaRecorder(this.stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = async (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                            // Send audio chunk to WebSocket server
                            await this.sendAudioChunkToWebSocket(event.data);
                        }
                    };
                    
                    // Start recording with small time slices for real-time streaming
                    this.mediaRecorder.start(1000); // 1 second chunks
                    
                    this.addDebugInfo('Audio streaming started');
                    
                } catch (error) {
                    this.addDebugInfo(`Audio streaming error: ${error.message}`);
                    console.error('Failed to start audio streaming:', error);
                }
            }

            async sendAudioChunkToGemini(audioChunk) {
                try {
                    // Convert audio chunk to the format expected by Gemini
                    const audioBuffer = await audioChunk.arrayBuffer();
                    const base64Audio = this.arrayBufferToBase64(audioBuffer);
                    
                    this.addDebugInfo(`Sending audio chunk: ${audioBuffer.byteLength} bytes`);
                    
                    // Send audio to Gemini Live API using sendRealtimeInput
                    await this.liveSession.sendRealtimeInput({
                        audio: {
                            data: base64Audio,
                            mimeType: "audio/pcm;rate=16000"
                        }
                    });
                    
                } catch (error) {
                    this.addDebugInfo(`Audio send error: ${error.message}`);
                    console.error('Failed to send audio chunk:', error);
                }
            }

            stopRecording() {
                if (this.isRecording) {
                    this.addDebugInfo('Stopping recording...');
                    
                    this.isRecording = false;
                    
                    if (this.mediaRecorder) {
                        this.mediaRecorder.stop();
                    }
                    
                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop());
                    }
                    
                    this.micButton.classList.remove('recording');
                    this.micButton.innerHTML = 'üé§';
                    this.updateStatus('Connected! Click microphone to talk', 'connected');
                    
                    this.stopWaveAnimation();
                    this.addMessage('üé§ Recording stopped', 'user');
                }
            }

            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return window.btoa(binary);
            }

            startWaveAnimation() {
                const animate = () => {
                    if (!this.isRecording) return;
                    
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    const bars = this.waveform.querySelectorAll('.wave-bar');
                    bars.forEach((bar, index) => {
                        const value = this.dataArray[index] || 0;
                        const height = Math.max(5, (value / 255) * 50);
                        bar.style.height = height + 'px';
                    });
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }

            stopWaveAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                const bars = this.waveform.querySelectorAll('.wave-bar');
                bars.forEach(bar => {
                    bar.style.height = '10px';
                });
            }

            disconnect() {
                this.addDebugInfo('Disconnecting...');
                if (this.ws) {
                    this.ws.close();
                }
                this.handleDisconnection();
            }

            handleDisconnection() {
                this.isConnected = false;
                this.isRecording = false;
                
                this.micButton.disabled = true;
                this.micButton.classList.remove('connected', 'recording');
                this.micButton.innerHTML = 'üé§';
                
                this.connectBtn.disabled = false;
                this.disconnectBtn.disabled = true;
                
                this.stopWaveAnimation();
                this.updateStatus('Disconnected. Click Connect to start again');
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }

            updateStatus(message, type = '') {
                this.statusEl.textContent = message;
                this.statusEl.className = 'status ' + type;
            }

            addMessage(text, sender) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${sender}`;
                messageEl.textContent = text;
                
                this.conversationLog.appendChild(messageEl);
                this.conversationLog.scrollTop = this.conversationLog.scrollHeight;
            }
        }

        // Initialize the app when the page loads
        window.addEventListener('load', () => {
            new GeminiNativeAudioChat();
        });

        // Telegram WebApp specific code
        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>
